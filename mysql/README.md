# MySQL

## [MySQL语法](https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/database/%E4%B8%80%E5%8D%83%E8%A1%8CMySQL%E5%91%BD%E4%BB%A4.md)

## 杂项 [参考](https://blog.csdn.net/xu_san_duo/article/details/78832884)
### 数据库命名规范
- 所有数据库对象名称必须使用小写字母并用下划线分割
- 所有数据库对象名称禁止使用 [MySQL保留关键字](https://www.cnblogs.com/Z-Fanghan/p/6892944.html)（如果表名中包含关键字查询时，需要将其用单引号括起来）
- 数据库对象的命名要能做到见名识意，并且最好不要超过 32 个字符
- 临时库表必须以 tmp_为前缀并以日期为后缀，备份表必须以 bak_为前缀并以日期 (时间戳) 为后缀
- 所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）

### 数据库基本设计规范
1. 所有表必须使用 Innodb 存储引擎；
2. 数据库和表的字符集统一使用 UTF8，不同的字符集进行比较前需要进行转换会造成索引失效，如果数据库中有存储 emoji 表情的需要，字符集需要采用 utf8mb4 字符集；
3. 所有表和字段都需要添加注释；
4. 尽量控制单表数据量的大小,建议控制在 500 万以内；
5. 谨慎使用 MySQL 分区表；
6. 尽量做到冷热数据分离,减小表的宽度，MySQL 限制每个表最多存储 4096 列，并且每一行数据的大小不能超过 65535 字节；
7. 禁止在表中建立预留字段；
- 预留字段的命名很难做到见名识义；
- 预留字段无法确认存储的数据类型，所以无法选择合适的类型；
- 对预留字段类型的修改，会对表进行锁定；
8. 禁止在数据库中存储图片,文件等大的二进制数据。

### 数据库字段设计规范
1. 优先选择符合存储需要的最小的数据类型；
> 原因：  
  列的字段越大，建立索引时所需要的空间也就越大，这样一页中所能存储的索引节点的数量也就越少也越少，在遍历时所需要的 IO 次数也就越多，索引的性能也就越差。  
  方法：  
  a.将字符串转换成数字类型存储,如:将 IP 地址转换成整形数据  
  MySQL 提供了两个方法来处理 ip 地址：  
  ` inet_aton 把 ip 转为无符号整型 (4-8 位)
    inet_ntoa 把整型的 ip 转为地址`  
  插入数据前，先用 inet_aton 把 ip 地址转为整型，可以节省空间，显示数据时，使用 inet_ntoa 把整型的 ip 地址转为地址显示即可。  
  b.对于非负型的数据 (如自增 ID,整型 IP) 来说,要优先使用无符号整型来存储  
  原因：  
  无符号相对于有符号可以多出一倍的存储空间  
    `SIGNED INT -2147483648~2147483647  
    UNSIGNED INT 0~4294967295`  
  VARCHAR(N) 中的 N 代表的是字符数，而不是字节数，使用 UTF8 存储 255 个汉字 Varchar(255)=765 个字节。过大的长度会消耗更多的内存。
2. 避免使用 TEXT,BLOB 数据类型，最常见的 TEXT 类型可以存储 64k 的数据；
> a. 建议把 BLOB 或是 TEXT 列分离到单独的扩展表中  
> b. TEXT 或 BLOB 类型只能使用前缀索引
3. 避免使用 ENUM 类型；
- 修改 ENUM 值需要使用 ALTER 语句
- ENUM 类型的 ORDER BY 操作效率低，需要额外操作
- 禁止使用数值作为 ENUM 的枚举值
4. 尽可能把所有列定义为 NOT NULL；
- 索引 NULL 列需要额外的空间来保存，所以要占用更多的空间
- 进行比较和计算时要对 NULL 值做特别的处理
- 将打算加索引的列设置为 NOT NULL ，否则将导致引擎放弃使用索引而进行全表扫描
5. 使用 TIMESTAMP(4 个字节) 或 DATETIME 类型 (8 个字节) 存储时间;
> 用字符串存储日期型的数据（不正确的做法）  
> 缺点 1：无法用日期函数进行计算和比较  
> 缺点 2：用字符串存储日期要占用更多的空间
6. 同财务相关的金额类数据必须使用 decimal 类；

### 索引设计规范
1. 限制每张表上的索引数量,建议单张表索引不超过 5 个；
> 索引并不是越多越好！索引可以提高效率同样可以降低效率。  
  索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。
2. 禁止给表中的每一列都建立单独的索引；
3. 每个 Innodb 表必须有个主键；
- 不要使用更新频繁的列作为主键，不适用多列主键（相当于联合索引）
- 不要使用 UUID,MD5,HASH,字符串列作为主键（无法保证数据的顺序增长）
- 主键建议使用自增 ID 值
4. 常见索引列建议；
- 出现在 SELECT、UPDATE、DELETE 语句的 WHERE 从句中的列
- 包含在 ORDER BY、GROUP BY、DISTINCT 中的字段
- 不要将符合 1 和 2 中的字段的列都建立一个索引， 通常将 1、2 中的字段建立联合索引效果更好
- 多表 join 的关联列，在这些外键列上加索引，可以加快连接的速度
5. 如何选择索引列的顺序；
- 区分度最高的放在联合索引的最左侧（区分度=列中不同值的数量/列的总行数）
- 尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO 性能也就越好）
- 使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）
6. 避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）；
7. 对于频繁的查询优先考虑使用覆盖索引，覆盖索引的好处：
- 避免 Innodb 表进行索引的二次查询
- 可以把随机 IO 变成顺序 IO 加快查询效率
8. [尽量避免使用外键约束](https://www.cnblogs.com/youngdeng/p/12857093.html)；
- 不建议使用外键约束（foreign key），但一定要在表与表之间的关联键上建立索引
- 外键可用于保证数据的参照完整性，但建议在业务端实现
- 外键会影响父表和子表的写操作从而降低性能
9. 删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗；

### 数据库 SQL 开发规范
1. 建议使用预编译语句进行数据库操作；
- 预编译语句可以重复使用这些计划，减少 SQL 编译所需要的时间，还可以解决动态 SQL 所带来的 SQL 注入的问题。
- 只传参数，比传递 SQL 语句更高效。
- 相同语句可以一次解析，多次使用，提高处理效率。
2. 避免数据类型的隐式转换，隐式转换会导致索引失效；
3. 充分利用表上已经存在的索引，避免使用双%号的查询条件，如果无前置%,只有后置%，是可以用到列上的索引的；
4. 数据库设计时，应该要对以后扩展进行考虑；
5. 程序连接不同的数据库使用不同的账号，进制跨库查询
- 为数据库迁移和分库分表留出余地
- 降低业务耦合度
- 避免权限过大而产生的安全风险
6. 禁止使用 SELECT * 必须使用 SELECT <字段列表> 查询
- 消耗更多的 CPU 和 IO 以网络带宽资源
- 无法使用覆盖索引
- 可减少表结构变更带来的影响
7. 禁止使用不含字段列表的 INSERT 语句；
8. 避免使用子查询，可以把子查询优化为 join 操作；
> 子查询性能差的原因：  
  子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，
  所以查询性能会受到一定的影响。特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大。  
  由于子查询会产生大量的临时表也没有索引，所以会消耗过多的 CPU 和 IO 资源，产生大量的慢查询。
9. 避免使用 JOIN 关联太多的表，MySQL 最多允许关联 61 个表，建议不超过 5 个；
10. 减少同数据库的交互次数；
11. 对应同一列进行 or 判断时，使用 in 代替 or，in 的值不要超过 500 个，in 操作可以更有效的利用索引，or 大多数情况下很少能利用到索引；
12. WHERE 从句中禁止对列进行函数转换和计算，对列进行函数转换或计算时会导致无法使用索引；
13. 在明显不会有重复值时使用 UNION ALL 而不是 UNION；
- UNION 会把两个结果集的所有数据放到临时表中后再进行去重操作
- UNION ALL 不会再对结果集进行去重操作
14. 拆分复杂的大 SQL 为多个小 SQL
- 大 SQL 逻辑上比较复杂，需要占用大量 CPU 进行计算的 SQL
- MySQL 中，一个 SQL 只能使用一个 CPU 进行计算
- SQL 拆分后可以通过并行执行来提高处理效率
  
## 索引和锁 [参考](https://juejin.im/post/5b55b842f265da0f9e589e79)
### 索引
1. 存储结构
Mysql的基本存储结构是页  
![页的结构](https://user-gold-cdn.xitu.io/2018/7/23/164c6d7a53a7920b?imageslim)  
插入一条记录的过程如下：  
![记录插入过程](https://user-gold-cdn.xitu.io/2018/7/23/164c6d7a53b78847?imageslim)  
各个数据页可以组成一个**双向链表**，而每个数据页中的记录又可以组成一个**单向链表**；每个数据页都会为存储在它里边儿的记录生成一个页目录，
在通过主键查找某条记录的时候可以在页目录中使用**二分法**快速定位到对应的槽，
然后再遍历该槽对应分组中的记录即可快速找到指定的记录以其他列(非主键)作为搜索条件：只能从最小记录开始依次遍历单链表中的每条记录。
2. 索引是如何加快查找速度的？  
查找id为8的记录过程如下：  
![查找过程](https://user-gold-cdn.xitu.io/2018/7/23/164c6d7a5663f62b?imageslim)  
没有用索引我们是需要遍历双向链表来定位对应的页，现在通过**目录**就可以很快地定位到对应的页上，
其实底层结构就是B+树，B+树作为树的一种实现，能够让我们很快地查找出对应的记录。
3. 索引降低增删改的速度  
B+树是平衡树的一种
> 平衡树：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。
- B+树是一颗平衡树，如果我们对这颗树增删改的话，那肯定会破坏它的原有结构
- 要维持平衡树，就必须做额外的工作。正因为这些额外的工作开销，导致索引会降低增删改的速度
4. 聚集和非聚集索引（聚簇索引与非聚簇索引）
- 简单概括：
  - 聚集索引就是将数据存储与索引放到了一块，找到索引也就找到了数据
  - 非聚集索引就是将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因
- 区别：
  - 聚集索引在叶子节点存储的是表中的数据
  - 非聚集索引在叶子节点存储的是主键和索引列
  - 使用非聚集索引查询出数据时，拿到叶子上的主键再去查到想要查找的数据。(拿到主键再查找这个过程叫做回表)   

何时使用聚簇索引或非聚簇索引
  
使用动作描述|使用聚簇索引|使用非聚簇索引
:---------:|:---------:|:---------:
列经常被分组排序|√|√
返回某范围内的数据|√|×
一个或极少不同的值|×|×
小数目不同的值|√|×
大数目不同的值|×|√
频繁更新的列|×|√
外键列|√|√
主键列|√|√
频繁修改索引列|×|√

5. 索引最左匹配原则
- 索引可以简单如一个列(a)，也可以复杂如多个列(a, b, c, d)，即联合索引。
- 如果是联合索引，那么key也由多个列组成，同时，索引只能用于查找key是否存在（相等），遇到范围查询(>、<、between、like左匹配)等就不能进一步匹配了，后续退化为线性查找。
- 因此，列的排列顺序决定了可命中索引的列数。
- 索引命中只能是相等的情况，不能是范围匹配
- 不需要考虑=、in等的顺序，mysql会自动优化这些条件的顺序，以匹配尽可能多的索引列

### 锁
1. MVCC和事务的隔离级别  
MVCC(Multi-Version Concurrency Control)多版本并发控制，可以简单地认为：**MVCC就是行级锁的一个变种(升级版)**。  
在表锁中我们读写是**阻塞**的，基于提升并发性能的考虑，MVCC一般读写是**不阻塞**的(所以说MVCC很多情况下避免了加锁的操作)。  
MVCC实现的读写不阻塞正如其名：多版本并发控制--->通过一定机制生成一个数据请求**时间点的一致性数据快照（Snapshot)**，
并用这个快照来提供一定级别（语句级或事务级）的一致性读取。从用户的角度来看，好像是数据库可以提供同一数据的多个版本。  
>快照有两个级别：  
语句级：针对于Read committed隔离级别  
事务级别：针对于Repeatable read隔离级别
2. 隔离级别
- `Read uncommitted`：会出现脏读，不可重复读，幻读
- `Read committed`：会出现不可重复读，幻读
- `Repeatable read`：会出现幻读(但在Mysql实现的Repeatable read配合gap锁不会出现幻读！)
- `Serializable`：串行，避免以上的情况！
---
`Read uncommitted`会出现的现象--->脏读：一个事务读取到另外一个事务未提交的数据  
出现脏读的本质就是因为**操作(修改)完该数据就立马释放掉锁**，导致读的数据就变成了无用的或者是错误的数据。

---

`Read committed`避免脏读：  
就是**把释放锁的位置调整到事务提交之后**，此时在事务提交前，其他进程是无法对该行数据进行读取的，包括任何操作  
但`Read committed`出现的现象--->不可重复读：一个事务读取到另外一个事务已经提交的数据，也就是说一个事务可以看到其他事务所做的修改  
即：**A查询数据库得到数据，B去修改数据库的数据，导致A多次查询数据库的结果都不一样**

---

`Repeatable read`避免不可重复读是：使用**事务级别的快照**！每次读取的都是当前事务的版本，即使被修改了，也只会读取当前事务版本的数据。  
`Read committed`是**语句级别的快照**！每次读取的都是当前最新的版本！  
至于虚读(幻读)：是指**在一个事务内读取到了别的事务插入的数据，导致前后读取不一致**。
> MySQL的Repeatable read隔离级别加上GAP间隙锁已经处理了幻读了。
3. 乐观锁与悲观锁
- 乐观锁是一种思想，具体实现是，表中有一个版本字段，第一次读的时候，获取到这个字段。处理完业务逻辑开始更新的时候，
需要再次查看该字段的值是否和第一次的一样。如果一样更新，反之拒绝。之所以叫乐观，因为这个模式没有从数据库加锁，
等到更新的时候再判断是否可以更新。
- 悲观锁是数据库层面加锁，都会阻塞去等待锁。
4. 间隙锁GAP
当我们用范围条件检索数据而不是相等条件检索数据，并请求共享或排他锁时，
InnoDB会给符合范围条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，
叫做“间隙（GAP)”。InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁。  
间隙锁只会在`Repeatable read`隔离级别下使用~  
InnoDB使用间隙锁的目的有两个：
- 为了防止幻读(上面也说了，`Repeatable read`隔离级别下再通过GAP锁即可避免了幻读)
- 满足恢复和复制的需要：在一个事务未提交前，其他并发事务不能插入满足其锁定条件的任何记录，也就是不允许出现幻读


