# JVM

#### 介绍
&emsp;&emsp;学习过程中的代码

## JVM体系概览
  &emsp;&emsp;[JVM体系概览](https://gitee.com/a1031749665/learning_code_warehouse/blob/master/jvm/image/JVM%E4%BD%93%E7%B3%BB%E6%A6%82%E8%A7%88.png)
  
### 类装载器ClassLoader
  &emsp;&emsp;负责加在class文件，class文件在文件开头有特定的文件标示，将class文件字节码内容加载到内存中，并将这些内容转换成方法区中的运行时数据结构并且ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。  
  &emsp;&emsp;[类装载器ClassLoader](https://gitee.com/a1031749665/learning_code_warehouse/blob/master/jvm/image/ClassLoader.png)
  
  #### 加载器种类
  1. 启动类加载器（Bootstrap）C++；
  2. 扩展类加载器（Extension）Java；
  3. 应用程序类加载器（AppClassLoader），也叫系统类加载器，加载当前应用的classpath的所有类；
  4. 用户自定义加载器，Java.lang.ClassLoader的子类，用户可以定制类的加载方式。
  
  #### 双亲委派机制
  &emsp;&emsp;当一个类收到了类加载器请求，它首先不会尝试直接去加载这个类，而是把这个请求委派给父类去完成，每一个层次加载器都是如此，因此所有的加载请求都应该传送到启动类加载器中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class），子类加载器才会尝试直接去加载。  
  &emsp;&emsp;采用双亲委派的一个好处是比如加载位于rt.jar包中的类java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样的一个object对象。  
  &emsp;&emsp;**简而言之：加载一个类的时候会先让父类加载器去加载，当父加载器未能加载时才会轮到子加载器，这样提高了Java的安全性。**

### PC寄存器
  &emsp;&emsp;1. 每个线程都有一个程序计数器，是线程私有的，就是一个指针，指向方法区中的方法字节码（用来存储指向下一条指令的地址，也即将要执行的指令代码），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不计；  
  &emsp;&emsp;2. 这块内存区域很小，它是当前线程所执行的字节码行号指示器，字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令；  
  &emsp;&emsp;3. 如果执行的是一个native方法，那这个计数器是空的；  
  &emsp;&emsp;4. 用以完成分支、循环、跳转、异常处理、线程恢复等基础功能；不会发生内存溢出（OOM）错误。  
  &emsp;&emsp;**简而言之：是一个指针，表明了执行完一个方法后下一个要执行的方法。**
  
### Method Area方法区
  1. 供各线程共享的运行时内存区。它存储了每一个类的结构信息，例如运行时常量池（Runtiome Constant Pool）、字段和方法数据、构造函数和普通方法的字节码内容；
  2. 上面讲的是规范，在不同的虚拟机里头实现是不一样的，最典型的就是永久代（PermGen space）和元空间（Metaspace）；
  3. 实例变量存在堆内存中，和方法区无关。

### Stack栈
  &emsp;&emsp;栈也叫栈内存，主管Java程序的运行，是在现场创建时创建，它的生命周期是跟随线程的生命周期，线程结束栈内存也就释放，对于栈来说不存在垃圾回收问题，只要线程已结束该栈就over，生命周期和线程一致，是线程私有的。  
  &emsp;&emsp;**栈存储的东西：8种基本类型的变量+对象单独引用变量+实例方法。**

  ####栈帧存储的数据：
   - 本地变量（Local Variables）：输入参数和输出参数以及方法内的变量；
   - 栈操作（Operand Stack）：记录出栈、入栈的操作；
   - 栈帧数据（Frame Data）：包括类文件、方法等。


事件| Eden区资源数 | from区资源数 | to区资源 
:---------:|:---------:|:---------:|:---------:
达到触发条件|100<br>（设100达到触发条件）|0|0
第一次触发GC|0<br>（全部清除）|2<br>（将幸存的资源复制到这来）|0
第一次GC完成|0|2|0
达到触发条件|100（设100达到触发条件）|2|0
from和to发生交换  原from变为to|100<br>（设100达到触发条件）|2-2|0+2
第二次触发GC|0<br>（全部清除）|2+2<br>（将幸存的资源复制到这来）|0
第二次GC完成|0|4|0
